/*
* This one file source has been generated by ProgTestTest
*
* https://github.com/KubaBoi/ptt
*
* version: 1.0.8
* author: Jakub Anderle
*/

#include <stdio.h>
#include <cstdlib>
#include <cstdint>
#include <cstdio>
#include <stdarg.h>
#include <cstring>


#ifndef VARIABLES_H
#define VARIABLES_H

/*
0 - only wanted ouput
1 - debug
2 - only debug
*/
#define PRINT_STATE 0

#define CHAR_BLOCK 10
#define LINE_LENGTH 65
#define RECT_LENGTH 4
#define MATRIX_LENGTH 16
#define MATRIX_SIZE MATRIX_LENGTH*MATRIX_LENGTH

typedef struct cell {
    int count;
    bool posibs[MATRIX_LENGTH];
} CELL;

#endif

#define INPUT_H


void nullString(char *str, int index, int size) {
	for (int i = index; i < size; i++) str[i] = 0;
}

int appendString(char *str, char *temp, int *filled) {
	int f = *filled;
	for (int i = 0; i < CHAR_BLOCK; i++) {
		if (temp[i] == '\n') {
			*filled = f;
			return 1;
		}

		str[f++] = temp[i];
		if (temp[i] == 0) f--;
	}
	*filled = f;
	return 0;
}

char* readLine(int* length) {
	int size = CHAR_BLOCK;
	char *string = (char *)malloc(size);
	int filled = 0;

	nullString(string, 0, size);

	char *newStr = (char *)malloc(CHAR_BLOCK);

	while (true) {
		nullString(newStr, 0, CHAR_BLOCK);

		if (fgets(newStr, sizeof(newStr), stdin) == NULL) {
			if (filled == 0) {
				free(string);
				free(newStr);
				return NULL;
			}
            *length = filled;
			break;
		}

		if (size < filled + CHAR_BLOCK) {
			size *= 2;
			string = (char *)realloc(string, size);
			nullString(string, filled, size);
		}

		if (appendString(string, newStr, &filled)) break;
	}

    *length = filled;
	free(newStr);
	return string;
}

int fillMatrixLine(char* matrix, char* line, int lineIndex) {
    int startIndex = lineIndex * MATRIX_LENGTH;
    for (int i = 0; i < MATRIX_LENGTH; i++) {
        int indexInLine = 2 + (i * 4);
        int index = startIndex + i;
        
        char c = line[indexInLine];
        if (c != ' ' && (c < 'a' || c > 'p')) return 1;

        matrix[index] = line[indexInLine];
    }
    return 0;
}

int readInput(char* matrix) {
    int length;
    int counter = 0;
    int lineIndex = 0;
    
    char* line = readLine(&length);
    while (line) {
        counter++;
        if (length != LINE_LENGTH) return 1;

        if (!(counter % 2)) {
            if (fillMatrixLine(matrix, line, lineIndex++)) return 1;
        }

        free(line);
        line = readLine(&length);
    }
    if (counter != 33) return 1;

    return 0;
}
#define PRINT_H
#define HELP_H


void getCoordinates(int index, int* x, int* y) {
    if (index >= MATRIX_SIZE) return;

    *x = index % MATRIX_LENGTH;
    *y = index / MATRIX_LENGTH;
}

int getIndex(int x, int y) {
    return y * MATRIX_LENGTH + x;
}

int getCharValue(char c) {
    if (c == ' ') return MATRIX_LENGTH;
    return c - 'a'; // 97
}

int getRect(int index) {
    int x, y;
    getCoordinates(index, &x, &y);
    return (x / 4) + (y / 4) * 4;
}

CELL* initCell() {
    CELL* cell = (CELL*) malloc(sizeof(*cell));
    cell->count = 0;
    for (int i = 0; i < MATRIX_LENGTH; i++) cell->posibs[i] = false;
    return cell;
}

void freeCells(uintptr_t* cells) {
    for (int i = 0; i < MATRIX_SIZE; i++) {
        CELL* cell = (CELL*) cells[i];
        free(cell);
    }
    free(cells);
}

bool* makeBooleanArray() {
    bool* array = (bool*) malloc(MATRIX_LENGTH+1);
    for (int i = 0; i < MATRIX_LENGTH+1; i++) array[i] = false;
    return array;
}


void print(const char* format, ...) {
    if (PRINT_STATE == 2) return;

    va_list valist;
    va_start(valist, format);
    vprintf(format, valist); fflush(stdin);
}

void printd(const char* format, ...) {
    if (PRINT_STATE == 0) return;

    va_list valist;
    va_start(valist, format);
    vprintf(format, valist); fflush(stdin);
}

void printDelimiter(bool full) {
    for (int i = 0; i < MATRIX_LENGTH; i++) {
        if (full) print("+---");
        else print("+   ");
    }
    print("+\n");
}

void printMatrix(char* matrix) {
    printDelimiter(true);
    for (int i = 0; i < MATRIX_SIZE; i++) {
        if (!(i % 4)) print("| %c   ", matrix[i]);
        else if (!((i + 1) % 16)) {
            print("%c |\n", matrix[i]);
            printDelimiter(!((i + 1) % 64));
        }
        else if (!((i + 1) % 4)) print("%c ", matrix[i]);
        else print("%c   ", matrix[i]);
    }
}

void printPosCells(char* matrix, uintptr_t* posCells) {
    int count = 0;
    int countChars = 0;
    int max = 0;

    for (int i = 0; i < MATRIX_SIZE; i++) {
        CELL* cell = (CELL*) posCells[i];
        if (matrix[i] != ' ') continue;

        int x, y;
        getCoordinates(i, &x, &y);

        for (int j = 0; j < MATRIX_LENGTH; j++) {
            printd("%d ", cell->posibs[j]);
        }
        printd("    - %d:%d", x, y);
        printd("\n");
    
        countChars += cell->count;
        if (cell->count > max) max = cell->count;
        count++;
    }
    printd("Max: %d\n", max);
    printd("%d, %d\n", count, countChars);
}
#define CHECKS_H


bool isPartOk(char* matrix, int x, int y, bool* arr) {
    int index = getIndex(x, y);
    int value = getCharValue(matrix[index]);
    if (arr[value] && value < MATRIX_LENGTH) return false;
    arr[value] = true;
    return true;
}

bool isRectangleOk(char* matrix, int number) {
    bool ret = true;
    bool* rectArray = makeBooleanArray();

    int xConst = (number % RECT_LENGTH) * RECT_LENGTH;
    int yConst = (number / RECT_LENGTH) * RECT_LENGTH;

    for (int y = 0; y < RECT_LENGTH; y++) {
        for (int x = 0; x < RECT_LENGTH; x++) {
            int X = x + xConst;
            int Y = y + yConst;
            int index = getIndex(X, Y);
            int value = getCharValue(matrix[index]);
            
            if (rectArray[value] && value < MATRIX_LENGTH) {
                ret = false;
                break;
            }
            rectArray[value] = true;
        }
    }
    free(rectArray);
    return ret;
}

bool isMatrixOk(char* matrix) {
    bool* rowArray;
    bool* colArray;

    for (int y = 0; y < MATRIX_LENGTH; y++) {
        bool ret = true;
        rowArray = makeBooleanArray();
        colArray = makeBooleanArray();
        for (int x = 0; x < MATRIX_LENGTH; x++) {
            ret = isPartOk(matrix, x, y, rowArray);
            if (!ret) break;

            ret = isPartOk(matrix, y, x, colArray);
            if (!ret) break;
        }
        free(rowArray);
        free(colArray);
        if (!ret) return false;
    }

    for (int i = 0; i < MATRIX_LENGTH; i++) {
        if (!isRectangleOk(matrix, i)) return false;
    }
    return true;
}
#define POSIBILITIES_H
#define REMOVES_H


int removePosInRow(uintptr_t* posCells, int index, int value) {
    int x, y;
    getCoordinates(index, &x, &y);
    int counter = 0;

    for (int i = 0; i < MATRIX_LENGTH; i++) {
        int indY = getIndex(i, y);
        CELL* cellY = (CELL*) posCells[indY];

        if (cellY->posibs[value]) {
            cellY->posibs[value] = false;
            cellY->count--;
            counter++;
        }
    }
    return counter;
}

int removePosInCol(uintptr_t* posCells, int index, int value) {
    int x, y;
    getCoordinates(index, &x, &y);
    int counter = 0;

    for (int i = 0; i < MATRIX_LENGTH; i++) {
        int indX = getIndex(x, i);
        CELL* cellX = (CELL*) posCells[indX];

        if (cellX->posibs[value]) {
            cellX->posibs[value] = false;
            cellX->count--;
            counter++;
        }
    }
    return counter;
}

int removePosInRect(uintptr_t* posCells, int index, int value) {
    int rect = getRect(index);
    int xConst = (rect % RECT_LENGTH) * RECT_LENGTH;
    int yConst = (rect / RECT_LENGTH) * RECT_LENGTH;
    int counter = 0;

    for (int y = 0; y < RECT_LENGTH; y++) {
        for (int x = 0; x < RECT_LENGTH; x++) {
            int X = x + xConst;
            int Y = y + yConst;
            int ind = getIndex(X, Y);

            CELL* cell = (CELL*) posCells[ind];
            if (cell->posibs[value]) {
                cell->posibs[value] = false;
                cell->count--;
                counter++;
            }
        }
    }
    return counter;
}

int removePos(uintptr_t* posCells, int index, int value) {
    int counter = 0;
    counter += removePosInRow(posCells, index, value);
    counter += removePosInCol(posCells, index, value);
    counter += removePosInRect(posCells, index, value);

    CELL* cell = (CELL*) posCells[index];
    cell->count = 0;
    for (int i = 0; i < MATRIX_LENGTH; i++) cell->posibs[i] = false; 

    return counter;
}


void getPartOfPosibs(char* matrix, int constant, bool isX, bool* arr) {
    for (int i = 0; i < MATRIX_LENGTH; i++) {
        int index;
        if (isX) index = getIndex(constant, i);
        else index = getIndex(i, constant);

        int value = getCharValue(matrix[index]);
        arr[value] = true;
    }
}

void getRectOfPosibs(char* matrix, int number, bool* arr) {
    int xConst = (number % RECT_LENGTH) * RECT_LENGTH;
    int yConst = (number / RECT_LENGTH) * RECT_LENGTH;

    for (int y = 0; y < RECT_LENGTH; y++) {
        for (int x = 0; x < RECT_LENGTH; x++) {
            int X = x + xConst;
            int Y = y + yConst;
            int index = getIndex(X, Y);

            int value = getCharValue(matrix[index]);
            arr[value] = true;
        }
    }
}

void makeOnePosib(char* matrix, uintptr_t* posCells, int index) {
    CELL* cell = (CELL*) posCells[index];
    bool* array = makeBooleanArray();
        
    int X, Y, rect;
    getCoordinates(index, &X, &Y);
    rect = getRect(index);
    
    getPartOfPosibs(matrix, Y, false, array);
    getPartOfPosibs(matrix, X, true, array);
    getRectOfPosibs(matrix, rect, array);
    
    for (int j = 0; j < MATRIX_LENGTH; j++) {
        if (!array[j]) {
            cell->count++;
            cell->posibs[j] = true;
        }
    }
    
    free(array);
}

void makePosibs(char* matrix, uintptr_t* posCells) {
    for (int i = 0; i < MATRIX_SIZE; i++) {
        
        CELL* cell = (CELL*) posCells[i];
        if (matrix[i] != ' ') {
            cell->count = 0;
            continue;
        }
        
        makeOnePosib(matrix, posCells, i);
    }
}
#define SOLVER_H
#define ANALYZER_H


int findMax(char* matrix, uintptr_t* posCells) {
    int max = 0;
    int maxIndex = 0;
    for (int i = 0; i < MATRIX_SIZE; i++) {
        CELL* cell = (CELL*) posCells[i];
        if (cell->count > max) {
            max = cell->count;
            maxIndex = i;
        }
    }
    return maxIndex;
}

int analyze(char* matrix, uintptr_t* posCells) {
    int filled = 0;
    for (int i = 0; i < MATRIX_SIZE; i++) {
        CELL* cell = (CELL*) posCells[i];
        if (matrix[i] != ' ') {
            filled++;
            continue;  
        }

        if (cell->count == 0) return 0;
    }

    if (filled == MATRIX_SIZE) return 1;
    return 2 + findMax(matrix, posCells);
}

double percentage(char* matrix) {
    int counter = 0;
    for (int i = 0; i < MATRIX_SIZE; i++) {
        if (matrix[i] != ' ') counter++;
    }
    return (double)counter / (MATRIX_SIZE) * 100;
}



int isAloneInRow(uintptr_t* posCells, int index, int value) {
    int x, y;
    int count = 0;
    getCoordinates(index, &x, &y);

    for (int i = 0; i < MATRIX_LENGTH; i++) {
        int ind = getIndex(i, y);
        CELL* cell = (CELL*) posCells[ind];
        if (cell->posibs[value]) count++;
    }
    return count;
}

int isAloneInCol(uintptr_t* posCells, int index, int value) {
    int x, y;
    int count = 0;
    getCoordinates(index, &x, &y);

    for (int i = 0; i < MATRIX_LENGTH; i++) {
        int ind = getIndex(x, i);
        CELL* cell = (CELL*) posCells[ind];
        if (cell->posibs[value]) count++;
    }
    return count;
}

int isAloneInRect(uintptr_t* posCells, int index, int value) {
    int count = 0;
    int rect = getRect(index);
    int xConst = (rect % RECT_LENGTH) * RECT_LENGTH;
    int yConst = (rect / RECT_LENGTH) * RECT_LENGTH;

    for (int y = 0; y < RECT_LENGTH; y++) {
        for (int x = 0; x < RECT_LENGTH; x++) {
            int X = x + xConst;
            int Y = y + yConst;
            int ind = getIndex(X, Y);

            CELL* cell = (CELL*) posCells[ind];
            if (cell->posibs[value]) count++;
        }
    }
    return count;
}

bool isAlone(uintptr_t* posCells, int index, int value) {
    return (isAloneInRow(posCells, index, value) == 1 ||
            isAloneInCol(posCells, index, value) == 1 ||
            isAloneInRect(posCells, index, value) == 1);

}

int fillOnePosibs(char* matrix, uintptr_t* posCells) {
    int changes = 0;
    for (int i = 0; i < MATRIX_SIZE; i++) {
        if (matrix[i] != ' ') continue;

        CELL* cell = (CELL*) posCells[i];
        if (cell->count == 1) {
            changes++;

            int x, y;
            getCoordinates(i, &x, &y);
            for (int j = 0; j < MATRIX_LENGTH; j++) {
                if (cell->posibs[j]) {
                    matrix[i] = 'a' + j;
                    removePos(posCells, i, j);
                    break;
                }
            }
        }
    }
    return changes;
}

int fillLonelyPosibs(char* matrix, uintptr_t* posCells) {
    int changes = 0;
    for (int i = 0; i < MATRIX_SIZE; i++) {
        if (matrix[i] != ' ') continue;

        CELL* cell = (CELL*) posCells[i];
        if (cell->count <= 0) continue;

        for (int j = 0; j < MATRIX_LENGTH; j++) {
            if (!cell->posibs[j]) continue;
            if (isAlone(posCells, i, j)) {
                changes++;
                matrix[i] = 'a' + j;
                removePos(posCells, i, j);
                break;
            }
        }
    }
    return changes;
}

int findLines(char* matrix, uintptr_t* posCells) {
    int changes = 0;
    for (int i = 0; i < MATRIX_SIZE; i++) {
        if (matrix[i] != ' ') continue;

        if (i > 20) return changes;

        CELL* cell = (CELL*) posCells[i];
        if (cell->count <= 0) continue;

        for (int j = 0; j < MATRIX_LENGTH; j++) {
            if (!cell->posibs[j]) continue;
            int countInRect = isAloneInRect(posCells, i, j);
            
            int countInRow = 0;
            int countInCol = 0;
            
            int X, Y;
            getCoordinates(i, &X, &Y);

            int rect = getRect(i);
            int xConst = (rect % RECT_LENGTH) * RECT_LENGTH;
            int yConst = (rect / RECT_LENGTH) * RECT_LENGTH;

            int* items = (int*) malloc(sizeof(*items) * countInRect);
            for (int o = 0; o < countInRect; o++) items[o] = 0;

            for (int o = 0; o < RECT_LENGTH; o++) {
                int xP = o + xConst;
                int yP = o + yConst;

                int indX = getIndex(xP, Y);
                int indY = getIndex(X, yP);

                CELL* cellX = (CELL*) posCells[indX];
                CELL* cellY = (CELL*) posCells[indY];

                if (cellX->posibs[j]) items[countInRow++] = indX;
                else if (cellY->posibs[j]) items[countInCol++] = indY;
            }

            if (countInRow == countInRect) {
                changes += removePosInRow(posCells, i, j);
            }
            else if (countInCol == countInRect) {
                changes += removePosInCol(posCells, i, j);
            }
            else {
                free(items);
                continue;
            }

            changes -= countInRect;

            for (int o = 0; o < countInRect; o++) {
                CELL* cell = (CELL*) posCells[items[o]];
                cell->posibs[j] = true;
                cell->count++;
            }
            free(items);
        }
    }
    return changes;
}

int findTwoLines(char* matrix, uintptr_t* posCells) {
    int changes = 0;

    for (int j = 0; j < MATRIX_LENGTH; j++) {
        uintptr_t* matrices = (uintptr_t*) malloc(sizeof(*matrices) * MATRIX_LENGTH);
        for (int i = 0; i < MATRIX_LENGTH; i++) {
            int multiplier = 1;
            for (int o = 0; o < RECT_LENGTH; o++) multiplier *= RECT_LENGTH;
            int index = (RECT_LENGTH * (i % RECT_LENGTH)) + ((i / RECT_LENGTH) * multiplier);
            
            int rect = getRect(index);
            int xConst = (rect % RECT_LENGTH) * RECT_LENGTH;
            int yConst = (rect / RECT_LENGTH) * RECT_LENGTH;
            
            int* rectMatrix = (int*) malloc(sizeof(*rectMatrix) * RECT_LENGTH * 2);
            for (int o = 0; o < RECT_LENGTH * 2; o++) rectMatrix[o] = 0;

            for (int y = 0; y < RECT_LENGTH; y++) {
                for (int x = 0; x < RECT_LENGTH; x++) {
                    int X = x + xConst;
                    int Y = y + yConst;
                    int ind = getIndex(X, Y);

                    CELL* cell = (CELL*) posCells[ind];
                    printd("%d ", cell->posibs[j]);
                    rectMatrix[y] += cell->posibs[j];
                    rectMatrix[RECT_LENGTH + x] += cell->posibs[j];
                }
                printd("\n");
            }
            for (int o = 0; o < RECT_LENGTH; o++) {
                printd("%d ", rectMatrix[o]);
            }
            printd("    ");
            for (int o = RECT_LENGTH; o < RECT_LENGTH * 2; o++) {
                printd("%d ", rectMatrix[o]);
            }
            printd("\n");
            
            matrices[i] = (uintptr_t) rectMatrix;
        }
        printd("\n");

        for (int i = 0; i < MATRIX_LENGTH; i++) {
            free((int*) matrices[i]);
        }
        free(matrices);
    }

    return changes;
}

int solve(char* matrix) {
    uintptr_t* posCells = (uintptr_t*) malloc(sizeof(*posCells) * MATRIX_SIZE);
    for (int i = 0; i < MATRIX_SIZE; i++) {
        posCells[i] = (uintptr_t) initCell();
    }

    makePosibs(matrix, posCells);

    int changes = 1;
    while (changes) {
        changes = 0;
        changes += fillOnePosibs(matrix, posCells);
        changes += fillLonelyPosibs(matrix, posCells);
    }

    int ret = analyze(matrix, posCells);

    if (ret >= 2) {
        int count = 0;
        int index = ret - 2;
        CELL* maxCell = (CELL*) posCells[index];
        for (int j = 0; j < MATRIX_LENGTH; j++) {
            if (maxCell->posibs[j]) {
                char* subMatrix = (char*) malloc(MATRIX_SIZE);
                strcpy(subMatrix, matrix);
                subMatrix[index] = 'a' + j;
                count += solve(subMatrix);
                free(subMatrix);
            }
        }
        ret = count;
    }
    
    freeCells(posCells);
    return ret;
}


int main() {
    char* matrix = (char*) malloc(MATRIX_SIZE);

    printf("Zadejte hexadoku:\n");

    if (readInput(matrix) || !isMatrixOk(matrix)) {
        printf("Nespravny vstup.\n");
        free(matrix);
        return 1;
    }
    
    double tempPerc = percentage(matrix);

    int result = solve(matrix);

    switch (result)
    {
    case 1:
        printMatrix(matrix);
        break;
    case 0:
        print("Reseni neexistuje.\n");
        break;
    default:
        print("Celkem reseni: %d\n", result);
        break;
    }
    printd("temp prcnt: %lf\n", tempPerc);
    printd("percetange: %lf\n", percentage(matrix));

    free(matrix);
}