/*
* This one file source has been generated by ProgTestTest
*
* https://github.com/KubaBoi/ptt
*
* version: 1.0.10
*/

#include <stdio.h>
#include <cstdlib>
#include <cstdint>
#include <cstdio>
#include <stdarg.h>
#include <cstring>


#ifndef VARIABLES_H
#define VARIABLES_H

/*
0 - only wanted ouput
1 - debug
2 - only debug
*/
#define PRINT_STATE 1

#define CHAR_BLOCK 10
#define LINE_LENGTH 65
#define RECT_LENGTH 4
#define MATRIX_LENGTH 16
#define MATRIX_SIZE MATRIX_LENGTH*MATRIX_LENGTH

typedef struct cell {
    int count;
    bool posibs[MATRIX_LENGTH];
} CELL;

#endif



void getCoordinates(int index, int* x, int* y) {
    if (index >= MATRIX_SIZE) return;

    *x = index % MATRIX_LENGTH;
    *y = index / MATRIX_LENGTH;
}

int getIndex(int x, int y) {
    return y * MATRIX_LENGTH + x;
}

int getCharValue(char c) {
    if (c == ' ') return MATRIX_LENGTH;
    return c - 'a'; // 97
}

int getRect(int index) {
    int x, y;
    getCoordinates(index, &x, &y);
    return (x / 4) + (y / 4) * 4;
}

CELL* initCell() {
    CELL* cell = (CELL*) malloc(sizeof(*cell));
    cell->count = 0;
    for (int i = 0; i < MATRIX_LENGTH; i++) cell->posibs[i] = false;
    return cell;
}

void freeCells(uintptr_t* cells) {
    for (int i = 0; i < MATRIX_SIZE; i++) {
        CELL* cell = (CELL*) cells[i];
        free(cell);
    }
    free(cells);
}

bool* makeBooleanArray() {
    bool* array = (bool*) malloc(MATRIX_LENGTH+1);
    for (int i = 0; i < MATRIX_LENGTH+1; i++) array[i] = false;
    return array;
}


void print(const char* format, ...) {
    if (PRINT_STATE == 2) return;

    va_list valist;
    va_start(valist, format);
    vprintf(format, valist); fflush(stdin);
}

void printd(const char* format, ...) {
    if (PRINT_STATE == 0) return;

    va_list valist;
    va_start(valist, format);
    vprintf(format, valist); fflush(stdin);
}

void printDelimiter(bool full) {
    for (int i = 0; i < MATRIX_LENGTH; i++) {
        if (full) print("+---");
        else print("+   ");
    }
    print("+\n");
}

void printMatrix(char* matrix) {
    printDelimiter(true);
    for (int i = 0; i < MATRIX_SIZE; i++) {
        if (!(i % 4)) print("| %c   ", matrix[i]);
        else if (!((i + 1) % 16)) {
            print("%c |\n", matrix[i]);
            printDelimiter(!((i + 1) % 64));
        }
        else if (!((i + 1) % 4)) print("%c ", matrix[i]);
        else print("%c   ", matrix[i]);
    }
}

void printPosCells(char* matrix, uintptr_t* posCells) {
    int count = 0;
    int countChars = 0;
    int max = 0;

    for (int i = 0; i < MATRIX_SIZE; i++) {
        CELL* cell = (CELL*) posCells[i];
        if (matrix[i] != ' ') continue;

        int x, y;
        getCoordinates(i, &x, &y);

        for (int j = 0; j < MATRIX_LENGTH; j++) {
            printd("%d ", cell->posibs[j]);
        }
        printd("    - %d:%d", x, y);
        printd("\n");
    
        countChars += cell->count;
        if (cell->count > max) max = cell->count;
        count++;
    }
    printd("Max: %d\n", max);
    printd("%d, %d\n", count, countChars);
}


void nullString(char *str, int index, int size) {
	for (int i = index; i < size; i++) str[i] = 0;
}

int appendString(char *str, char *temp, int *filled) {
	int f = *filled;
	for (int i = 0; i < CHAR_BLOCK; i++) {
		if (temp[i] == '\n') {
			*filled = f;
			return 1;
		}

		str[f++] = temp[i];
		if (temp[i] == 0) f--;
	}
	*filled = f;
	return 0;
}

char* readLine(int* length) {
	int size = CHAR_BLOCK;
	char *string = (char *)malloc(size);
	int filled = 0;

	nullString(string, 0, size);

	char *newStr = (char *)malloc(CHAR_BLOCK);

	while (true) {
		nullString(newStr, 0, CHAR_BLOCK);

		if (fgets(newStr, sizeof(newStr), stdin) == NULL) {
			if (filled == 0) {
				free(string);
				free(newStr);
				return NULL;
			}
            *length = filled;
			break;
		}

		if (size < filled + CHAR_BLOCK) {
			size *= 2;
			string = (char *)realloc(string, size);
			nullString(string, filled, size);
		}

		if (appendString(string, newStr, &filled)) break;
	}

    *length = filled;
	free(newStr);
	return string;
}

int fillMatrixLine(char* matrix, char* line, int lineIndex) {
    int startIndex = lineIndex * MATRIX_LENGTH;
    for (int i = 0; i < MATRIX_LENGTH; i++) {
        int indexInLine = 2 + (i * 4);
        int index = startIndex + i;

		if (!(i % 4)) {
			if (line[indexInLine - 1] != ' ' ||
				line[indexInLine - 2] != '|') return 1;
		}
		else if (line[indexInLine - 1] != ' ' ||
				line[indexInLine - 2] != ' ' ||
				line[indexInLine - 3] != ' ' ||
				line[indexInLine + 1] != ' ') return 1;
        
        char c = line[indexInLine];
        if (c != ' ' && (c < 'a' || c > 'p')) return 1;

        matrix[index] = line[indexInLine];
    }
	if (line[LINE_LENGTH - 1] != '|') return 1;
    return 0;
}

bool isDelimiterOk(char* line, int counter) {
	char del = ' ';
	if (!((counter - 1) % 8)) del = '-';
	
	for (int i = 0; i < LINE_LENGTH-1; i += 4) {
		if (line[i] != '+' ||
			line[i+1] != del ||
			line[i+2] != del ||
			line[i+3] != del) return false;
	}
	return line[LINE_LENGTH-1] == '+';
}

int readInput(char* matrix) {
    int length;
    int counter = 0;
    int lineIndex = 0;
    
    char* line = readLine(&length);
    while (line) {
        counter++;
        if (length != LINE_LENGTH) return 1;

        if (!(counter % 2)) {
            if (fillMatrixLine(matrix, line, lineIndex++)) return 1;
        }
		else if (!isDelimiterOk(line, counter)) return 1;

        free(line);
        line = readLine(&length);
    }
    if (counter != 33) return 1;

    return 0;
}


bool isPartOk(char* matrix, int x, int y, bool* arr) {
    int index = getIndex(x, y);
    int value = getCharValue(matrix[index]);
    if (arr[value] && value < MATRIX_LENGTH) return false;
    arr[value] = true;
    return true;
}

bool isRectangleOk(char* matrix, int number) {
    bool ret = true;
    bool* rectArray = makeBooleanArray();

    int xConst = (number % RECT_LENGTH) * RECT_LENGTH;
    int yConst = (number / RECT_LENGTH) * RECT_LENGTH;

    for (int y = 0; y < RECT_LENGTH; y++) {
        for (int x = 0; x < RECT_LENGTH; x++) {
            int X = x + xConst;
            int Y = y + yConst;
            int index = getIndex(X, Y);
            int value = getCharValue(matrix[index]);
            
            if (rectArray[value] && value < MATRIX_LENGTH) {
                ret = false;
                break;
            }
            rectArray[value] = true;
        }
    }
    free(rectArray);
    return ret;
}

bool isMatrixOk(char* matrix) {
    bool* rowArray;
    bool* colArray;

    for (int y = 0; y < MATRIX_LENGTH; y++) {
        bool ret = true;
        rowArray = makeBooleanArray();
        colArray = makeBooleanArray();
        for (int x = 0; x < MATRIX_LENGTH; x++) {
            ret = isPartOk(matrix, x, y, rowArray);
            if (!ret) break;

            ret = isPartOk(matrix, y, x, colArray);
            if (!ret) break;
        }
        free(rowArray);
        free(colArray);
        if (!ret) return false;
    }

    for (int i = 0; i < MATRIX_LENGTH; i++) {
        if (!isRectangleOk(matrix, i)) return false;
    }
    return true;
}


int removePosInRow(uintptr_t* posCells, int index, int value) {
    int x, y;
    getCoordinates(index, &x, &y);
    int counter = 0;

    for (int i = 0; i < MATRIX_LENGTH; i++) {
        int indY = getIndex(i, y);
        CELL* cellY = (CELL*) posCells[indY];

        if (cellY->posibs[value]) {
            cellY->posibs[value] = false;
            cellY->count--;
            counter++;
        }
    }
    return counter;
}

int removePosInCol(uintptr_t* posCells, int index, int value) {
    int x, y;
    getCoordinates(index, &x, &y);
    int counter = 0;

    for (int i = 0; i < MATRIX_LENGTH; i++) {
        int indX = getIndex(x, i);
        CELL* cellX = (CELL*) posCells[indX];

        if (cellX->posibs[value]) {
            cellX->posibs[value] = false;
            cellX->count--;
            counter++;
        }
    }
    return counter;
}

int removePosInRect(uintptr_t* posCells, int index, int value) {
    int rect = getRect(index);
    int xConst = (rect % RECT_LENGTH) * RECT_LENGTH;
    int yConst = (rect / RECT_LENGTH) * RECT_LENGTH;
    int counter = 0;

    for (int y = 0; y < RECT_LENGTH; y++) {
        for (int x = 0; x < RECT_LENGTH; x++) {
            int X = x + xConst;
            int Y = y + yConst;
            int ind = getIndex(X, Y);

            CELL* cell = (CELL*) posCells[ind];
            if (cell->posibs[value]) {
                cell->posibs[value] = false;
                cell->count--;
                counter++;
            }
        }
    }
    return counter;
}

int removePos(uintptr_t* posCells, int index, int value) {
    int counter = 0;
    counter += removePosInRow(posCells, index, value);
    counter += removePosInCol(posCells, index, value);
    counter += removePosInRect(posCells, index, value);

    CELL* cell = (CELL*) posCells[index];
    cell->count = 0;
    for (int i = 0; i < MATRIX_LENGTH; i++) cell->posibs[i] = false; 

    return counter;
}


void getPartOfPosibs(char* matrix, int constant, bool isX, bool* arr) {
    for (int i = 0; i < MATRIX_LENGTH; i++) {
        int index;
        if (isX) index = getIndex(constant, i);
        else index = getIndex(i, constant);

        int value = getCharValue(matrix[index]);
        arr[value] = true;
    }
}

void getRectOfPosibs(char* matrix, int number, bool* arr) {
    int xConst = (number % RECT_LENGTH) * RECT_LENGTH;
    int yConst = (number / RECT_LENGTH) * RECT_LENGTH;

    for (int y = 0; y < RECT_LENGTH; y++) {
        for (int x = 0; x < RECT_LENGTH; x++) {
            int X = x + xConst;
            int Y = y + yConst;
            int index = getIndex(X, Y);

            int value = getCharValue(matrix[index]);
            arr[value] = true;
        }
    }
}

void makeOnePosib(char* matrix, uintptr_t* posCells, int index) {
    CELL* cell = (CELL*) posCells[index];
    bool* array = makeBooleanArray();
        
    int X, Y, rect;
    getCoordinates(index, &X, &Y);
    rect = getRect(index);
    
    getPartOfPosibs(matrix, Y, false, array);
    getPartOfPosibs(matrix, X, true, array);
    getRectOfPosibs(matrix, rect, array);
    
    for (int j = 0; j < MATRIX_LENGTH; j++) {
        if (!array[j]) {
            cell->count++;
            cell->posibs[j] = true;
        }
    }
    
    free(array);
}

void makePosibs(char* matrix, uintptr_t* posCells) {
    for (int i = 0; i < MATRIX_SIZE; i++) {
        
        CELL* cell = (CELL*) posCells[i];
        if (matrix[i] != ' ') {
            cell->count = 0;
            continue;
        }
        
        makeOnePosib(matrix, posCells, i);
    }
}


int findMax(char* matrix, uintptr_t* posCells) {
    int max = 0;
    int maxIndex = 0;
    for (int i = 0; i < MATRIX_SIZE; i++) {
        CELL* cell = (CELL*) posCells[i];
        if (cell->count > max) {
            max = cell->count;
            maxIndex = i;
        }
    }
    return maxIndex;
}

int analyze(char* matrix, uintptr_t* posCells) {
    int filled = 0;
    for (int i = 0; i < MATRIX_SIZE; i++) {
        CELL* cell = (CELL*) posCells[i];
        if (matrix[i] != ' ') {
            filled++;
            continue;  
        }

        if (cell->count == 0) return 0;
    }

    if (filled == MATRIX_SIZE) return 1;
    return 2 + findMax(matrix, posCells);
}

double percentage(char* matrix) {
    int counter = 0;
    for (int i = 0; i < MATRIX_SIZE; i++) {
        if (matrix[i] != ' ') counter++;
    }
    return (double)counter / (MATRIX_SIZE) * 100;
}



int isAloneInRow(uintptr_t* posCells, int index, int value) {
    int x, y;
    int count = 0;
    getCoordinates(index, &x, &y);

    for (int i = 0; i < MATRIX_LENGTH; i++) {
        int ind = getIndex(i, y);
        CELL* cell = (CELL*) posCells[ind];
        if (cell->posibs[value]) count++;
    }
    return count;
}

int isAloneInCol(uintptr_t* posCells, int index, int value) {
    int x, y;
    int count = 0;
    getCoordinates(index, &x, &y);

    for (int i = 0; i < MATRIX_LENGTH; i++) {
        int ind = getIndex(x, i);
        CELL* cell = (CELL*) posCells[ind];
        if (cell->posibs[value]) count++;
    }
    return count;
}

int isAloneInRect(uintptr_t* posCells, int index, int value) {
    int count = 0;
    int rect = getRect(index);
    int xConst = (rect % RECT_LENGTH) * RECT_LENGTH;
    int yConst = (rect / RECT_LENGTH) * RECT_LENGTH;

    for (int y = 0; y < RECT_LENGTH; y++) {
        for (int x = 0; x < RECT_LENGTH; x++) {
            int X = x + xConst;
            int Y = y + yConst;
            int ind = getIndex(X, Y);

            CELL* cell = (CELL*) posCells[ind];
            if (cell->posibs[value]) count++;
        }
    }
    return count;
}

bool isAlone(uintptr_t* posCells, int index, int value) {
    return (isAloneInRow(posCells, index, value) == 1 ||
            isAloneInCol(posCells, index, value) == 1 ||
            isAloneInRect(posCells, index, value) == 1);

}

int fillOnePosibs(char* matrix, uintptr_t* posCells) {
    int changes = 0;
    for (int i = 0; i < MATRIX_SIZE; i++) {
        if (matrix[i] != ' ') continue;

        CELL* cell = (CELL*) posCells[i];
        if (cell->count == 1) {
            changes++;

            int x, y;
            getCoordinates(i, &x, &y);
            for (int j = 0; j < MATRIX_LENGTH; j++) {
                if (cell->posibs[j]) {
                    matrix[i] = 'a' + j;
                    removePos(posCells, i, j);
                    break;
                }
            }
        }
    }
    return changes;
}

int fillLonelyPosibs(char* matrix, uintptr_t* posCells) {
    int changes = 0;
    for (int i = 0; i < MATRIX_SIZE; i++) {
        if (matrix[i] != ' ') continue;

        CELL* cell = (CELL*) posCells[i];
        if (cell->count <= 0) continue;

        for (int j = 0; j < MATRIX_LENGTH; j++) {
            if (!cell->posibs[j]) continue;
            if (isAlone(posCells, i, j)) {
                changes++;
                matrix[i] = 'a' + j;
                removePos(posCells, i, j);
                break;
            }
        }
    }
    return changes;
}

int findLines(char* matrix, uintptr_t* posCells) {
    int changes = 0;

    for (int j = 0; j < MATRIX_LENGTH; j++) {
        /*
        Matrix 4x16 of posibilities in rows for each rectangle
        [0] is first rectangle first row,
        [1] is second rectangle first row
        [4] is first rectangle second row
        */
        int* rowsMatrix = (int*) malloc(sizeof(*rowsMatrix) * MATRIX_LENGTH * RECT_LENGTH);

        // Goes through every row (y value)
        for (int y = 0; y < MATRIX_LENGTH; y++) {
            // Goes through every rectangle (x value)
            for (int x = 0; x < RECT_LENGTH; x++) {
                int index = y * RECT_LENGTH + x; 
                rowsMatrix[index] = 0;

                for (int i = 0; i < RECT_LENGTH; i++) {
                    int ind = y * MATRIX_LENGTH + x * RECT_LENGTH + i;
                    CELL* cell = (CELL*) posCells[ind];
                    if (cell->posibs[j]) rowsMatrix[index]++;
                }
            }
        }

        printd("'%c' ===========\n", 'a' + j);
        for (int i = 0; i < MATRIX_LENGTH * RECT_LENGTH; i++) {
            printd("%d ", rowsMatrix[i]);
            if ((i+1) % 4 == 0) printd("\n");
            if ((i+1) % 16 == 0) printd("----\n");
        }

        /*
        Matrix 4x4 of counts of rows in rect
        */
        int* rowsCountPerColumn = (int*) malloc(sizeof(*rowsCountPerColumn) * MATRIX_LENGTH);
        for (int i = 0; i < MATRIX_LENGTH; i++) rowsCountPerColumn[i] = 0;

        for (int i = 0; i < MATRIX_LENGTH * RECT_LENGTH; i++) {
            int ind = (4 * (i / MATRIX_LENGTH)) + i % RECT_LENGTH;
            if (rowsMatrix[i]) rowsCountPerColumn[ind]++;
        } 

        for (int i = 0; i < MATRIX_LENGTH; i++) {
            printd("%d ", rowsCountPerColumn[i]);
        }
        printd("\n"); 

        for (int r = 0; r < RECT_LENGTH; r++) {
            for (int i = r*4; i < r + RECT_LENGTH - 1; i++) {
                int count = rowsCountPerColumn[i];
                int size = 0;
                /*
                Array of indexes which have same not-empty rows
                count of equalRows have to be same as count of
                not-empty rows
                */
                int* equalRows = (int*) malloc(sizeof(*equalRows) * count);
                for (int o = r; o < r + RECT_LENGTH; o++) {
                    if (count = rowsCountPerColumn[o]) {
                        equalRows[size++] = o;
                    }
                } 

                for (int o = 0; o < size; o++) {
                    
                }
            }
        }

        free(rowsCountPerColumn);
        free(rowsMatrix);
    }
    printd("=======\n");

    return changes;
}

int solve(char* matrix, int* iterations) {
    uintptr_t* posCells = (uintptr_t*) malloc(sizeof(*posCells) * MATRIX_SIZE);
    for (int i = 0; i < MATRIX_SIZE; i++) {
        posCells[i] = (uintptr_t) initCell();
    }

    makePosibs(matrix, posCells);

    int iter = 0;
    int changes = 1;
    while (changes) {
        iter++;
        changes = 0;
        changes += fillOnePosibs(matrix, posCells);
        changes += fillLonelyPosibs(matrix, posCells);
        if (iter == 1) changes += findLines(matrix, posCells);
    }

    *iterations += iter;
    int ret = analyze(matrix, posCells);

    if (ret >= 2) {
        int count = 0;
        int index = ret - 2;
        CELL* maxCell = (CELL*) posCells[index];
        for (int j = 0; j < MATRIX_LENGTH; j++) {
            if (maxCell->posibs[j]) {
                char* subMatrix = (char*) malloc(MATRIX_SIZE);
                strcpy(subMatrix, matrix);
                subMatrix[index] = 'a' + j;
                count += solve(subMatrix, iterations);
                free(subMatrix);
            }
        }
        ret = count;
    }
    
    freeCells(posCells);
    return ret;
}


int main() {
    char* matrix = (char*) malloc(MATRIX_SIZE);

    printf("Zadejte hexadoku:\n");

    if (readInput(matrix) || !isMatrixOk(matrix)) {
        printf("Nespravny vstup.\n");
        free(matrix);
        return 1;
    }
    
    double tempPerc = percentage(matrix);

    int iterations = 0;
    int result = solve(matrix, &iterations);

    switch (result)
    {
    case 1:
        printMatrix(matrix);
        break;
    case 0:
        print("Reseni neexistuje.\n");
        break;
    default:
        print("Celkem reseni: %d\n", result);
        break;
    }
    printd("temp prcnt: %lf\n", tempPerc);
    printd("percetange: %lf\n", percentage(matrix));
    printd("Iterations: %d\n", iterations);

    free(matrix);
}